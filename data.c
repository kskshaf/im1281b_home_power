#include "data.h"

IM1281B_PARAM IM1281B_OUT = {
    0,
    0,
    0,
    0,
    0,
    0
};  //数据输出结构体实例

/* Helper function for error handling. */
int check(enum sp_return result)
{
    /* For this example we'll just exit on any error by calling abort(). */
    char *error_message;

    switch (result) {
    case SP_ERR_ARG:
        log_error("Error: Invalid argument.");
        abort();
    case SP_ERR_FAIL:
        error_message = sp_last_error_message();
        log_error("Error: Failed: %s", error_message);
        sp_free_error_message(error_message);
        abort();
    case SP_ERR_SUPP:
        log_error("Error: Not supported.");
        abort();
    case SP_ERR_MEM:
        log_error("Error: Couldn't allocate memory.");
        abort();
    case SP_OK:
    default:
        return result;
    }
}

uint16_t combine_bytes(uint8_t high, uint8_t low) {
    return (((unsigned short)high) << 8) | low;
}

// Function to calculate Modbus CRC16
// Generated by Claude
uint16_t modbus_crc16(uint8_t *buffer, size_t length) {
    uint16_t crc = 0xFFFF;

    for (size_t i = 0; i < length; i++) {
        crc ^= buffer[i];
        for (int j = 0; j < 8; j++) {
            if (crc & 0x0001) {
                crc >>= 1;
                crc ^= 0xA001;
            } else {
                crc >>= 1;
            }
        }
    }
    return crc;
}

void ConvertBytesToUInt32Array(uint8_t* data, uint32_t* output) {
    for (int i = 0; i < 8; i++)
    {
        output[i] = ((uint32_t)data[i * 4] << 24) |
                ((uint32_t)data[i * 4 + 1] << 16) |
                ((uint32_t)data[i * 4 + 2] << 8)  |
                (uint32_t)data[i * 4 + 3];
    }
}

void get_module_data(uint8_t *frame)
{
    uint32_t output[8]={0};
    ConvertBytesToUInt32Array(frame, output);

    IM1281B_OUT.U  = output[0]*0.0001f;
    IM1281B_OUT.I  = output[1]*0.0001f;
    IM1281B_OUT.P  = output[2]*0.0001f;
    IM1281B_OUT.PF = output[4]*0.001f;
    IM1281B_OUT.T  = output[6]*0.01f;
    IM1281B_OUT.F  = output[7]*0.01f;

    // 将监测的数据覆盖写入文件
    FILE *fp = fopen(DATA_FILE, "w");
    if (fp != NULL) {
        fprintf(fp, "U=%.1f\nI=%.2f\nP=%.1f\nPF=%.3f\nT=%.1f\nF=%.1f\n",
                IM1281B_OUT.U,
                IM1281B_OUT.I,
                IM1281B_OUT.P,
                IM1281B_OUT.PF,
                IM1281B_OUT.T,
                IM1281B_OUT.F);
        fclose(fp);
    } else {
        log_error("打开 %s 失败", DATA_FILE);
    }
}

// 将电源状态写入 html 文件，以供其他设备访问电源状态
void write_pw_status_to_html(int status)
{
    FILE *fp = fopen(WEB_FILE, "w");
    if (fp != NULL) {
        if(status) {
            fprintf(fp, "ciallo-114514-power-off");
        } else {
            fprintf(fp, "ciallo-114514-status-ok");
        }

        fclose(fp);
    } else {
        log_error("打开 %s 失败", WEB_FILE);
    }
}

void error_to_data_file(void)
{
    // 清除数据
    FILE *fp = fopen(DATA_FILE, "w");
    if (fp != NULL) {
        fprintf(fp, "ERROR");
        fclose(fp);
    } else {
        log_error("打开 %s 失败", DATA_FILE);
    }
}